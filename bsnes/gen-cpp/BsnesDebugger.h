/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef BsnesDebugger_H
#define BsnesDebugger_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "debug_proto_types.h"



#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class BsnesDebuggerIf {
 public:
  virtual ~BsnesDebuggerIf() {}
  virtual int32_t get_cpu_reg(const BsnesRegister::type reg) = 0;
  virtual void get_cpu_regs(BsnesRegisters& _return) = 0;
  virtual void set_cpu_reg(const BsnesRegister::type reg, const int32_t value) = 0;
  virtual void read_memory(std::string& _return, const DbgMemorySource::type src, const int32_t address, const int32_t size) = 0;
  virtual void write_memory(const DbgMemorySource::type src, const int32_t address, const std::string& data) = 0;
  virtual void add_breakpoint(const DbgBreakpoint& bpt) = 0;
  virtual void del_breakpoint(const DbgBreakpoint& bpt) = 0;
  virtual void pause() = 0;
  virtual void resume() = 0;
  virtual void start_emulation() = 0;
  virtual void exit_emulation() = 0;
  virtual void step_into() = 0;
  virtual void step_over() = 0;
};

class BsnesDebuggerIfFactory {
 public:
  typedef BsnesDebuggerIf Handler;

  virtual ~BsnesDebuggerIfFactory() {}

  virtual BsnesDebuggerIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(BsnesDebuggerIf* /* handler */) = 0;
};

class BsnesDebuggerIfSingletonFactory : virtual public BsnesDebuggerIfFactory {
 public:
  BsnesDebuggerIfSingletonFactory(const ::std::shared_ptr<BsnesDebuggerIf>& iface) : iface_(iface) {}
  virtual ~BsnesDebuggerIfSingletonFactory() {}

  virtual BsnesDebuggerIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(BsnesDebuggerIf* /* handler */) {}

 protected:
  ::std::shared_ptr<BsnesDebuggerIf> iface_;
};

class BsnesDebuggerNull : virtual public BsnesDebuggerIf {
 public:
  virtual ~BsnesDebuggerNull() {}
  int32_t get_cpu_reg(const BsnesRegister::type /* reg */) {
    int32_t _return = 0;
    return _return;
  }
  void get_cpu_regs(BsnesRegisters& /* _return */) {
    return;
  }
  void set_cpu_reg(const BsnesRegister::type /* reg */, const int32_t /* value */) {
    return;
  }
  void read_memory(std::string& /* _return */, const DbgMemorySource::type /* src */, const int32_t /* address */, const int32_t /* size */) {
    return;
  }
  void write_memory(const DbgMemorySource::type /* src */, const int32_t /* address */, const std::string& /* data */) {
    return;
  }
  void add_breakpoint(const DbgBreakpoint& /* bpt */) {
    return;
  }
  void del_breakpoint(const DbgBreakpoint& /* bpt */) {
    return;
  }
  void pause() {
    return;
  }
  void resume() {
    return;
  }
  void start_emulation() {
    return;
  }
  void exit_emulation() {
    return;
  }
  void step_into() {
    return;
  }
  void step_over() {
    return;
  }
};

typedef struct _BsnesDebugger_get_cpu_reg_args__isset {
  _BsnesDebugger_get_cpu_reg_args__isset() : reg(false) {}
  bool reg :1;
} _BsnesDebugger_get_cpu_reg_args__isset;

class BsnesDebugger_get_cpu_reg_args {
 public:

  BsnesDebugger_get_cpu_reg_args(const BsnesDebugger_get_cpu_reg_args&);
  BsnesDebugger_get_cpu_reg_args& operator=(const BsnesDebugger_get_cpu_reg_args&);
  BsnesDebugger_get_cpu_reg_args() : reg((BsnesRegister::type)0) {
  }

  virtual ~BsnesDebugger_get_cpu_reg_args() noexcept;
  /**
   * 
   * @see BsnesRegister
   */
  BsnesRegister::type reg;

  _BsnesDebugger_get_cpu_reg_args__isset __isset;

  void __set_reg(const BsnesRegister::type val);

  bool operator == (const BsnesDebugger_get_cpu_reg_args & rhs) const
  {
    if (!(reg == rhs.reg))
      return false;
    return true;
  }
  bool operator != (const BsnesDebugger_get_cpu_reg_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_get_cpu_reg_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_get_cpu_reg_pargs {
 public:


  virtual ~BsnesDebugger_get_cpu_reg_pargs() noexcept;
  /**
   * 
   * @see BsnesRegister
   */
  const BsnesRegister::type* reg;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BsnesDebugger_get_cpu_reg_result__isset {
  _BsnesDebugger_get_cpu_reg_result__isset() : success(false) {}
  bool success :1;
} _BsnesDebugger_get_cpu_reg_result__isset;

class BsnesDebugger_get_cpu_reg_result {
 public:

  BsnesDebugger_get_cpu_reg_result(const BsnesDebugger_get_cpu_reg_result&);
  BsnesDebugger_get_cpu_reg_result& operator=(const BsnesDebugger_get_cpu_reg_result&);
  BsnesDebugger_get_cpu_reg_result() : success(0) {
  }

  virtual ~BsnesDebugger_get_cpu_reg_result() noexcept;
  int32_t success;

  _BsnesDebugger_get_cpu_reg_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const BsnesDebugger_get_cpu_reg_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const BsnesDebugger_get_cpu_reg_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_get_cpu_reg_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BsnesDebugger_get_cpu_reg_presult__isset {
  _BsnesDebugger_get_cpu_reg_presult__isset() : success(false) {}
  bool success :1;
} _BsnesDebugger_get_cpu_reg_presult__isset;

class BsnesDebugger_get_cpu_reg_presult {
 public:


  virtual ~BsnesDebugger_get_cpu_reg_presult() noexcept;
  int32_t* success;

  _BsnesDebugger_get_cpu_reg_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class BsnesDebugger_get_cpu_regs_args {
 public:

  BsnesDebugger_get_cpu_regs_args(const BsnesDebugger_get_cpu_regs_args&);
  BsnesDebugger_get_cpu_regs_args& operator=(const BsnesDebugger_get_cpu_regs_args&);
  BsnesDebugger_get_cpu_regs_args() {
  }

  virtual ~BsnesDebugger_get_cpu_regs_args() noexcept;

  bool operator == (const BsnesDebugger_get_cpu_regs_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_get_cpu_regs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_get_cpu_regs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_get_cpu_regs_pargs {
 public:


  virtual ~BsnesDebugger_get_cpu_regs_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BsnesDebugger_get_cpu_regs_result__isset {
  _BsnesDebugger_get_cpu_regs_result__isset() : success(false) {}
  bool success :1;
} _BsnesDebugger_get_cpu_regs_result__isset;

class BsnesDebugger_get_cpu_regs_result {
 public:

  BsnesDebugger_get_cpu_regs_result(const BsnesDebugger_get_cpu_regs_result&);
  BsnesDebugger_get_cpu_regs_result& operator=(const BsnesDebugger_get_cpu_regs_result&);
  BsnesDebugger_get_cpu_regs_result() {
  }

  virtual ~BsnesDebugger_get_cpu_regs_result() noexcept;
  BsnesRegisters success;

  _BsnesDebugger_get_cpu_regs_result__isset __isset;

  void __set_success(const BsnesRegisters& val);

  bool operator == (const BsnesDebugger_get_cpu_regs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const BsnesDebugger_get_cpu_regs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_get_cpu_regs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BsnesDebugger_get_cpu_regs_presult__isset {
  _BsnesDebugger_get_cpu_regs_presult__isset() : success(false) {}
  bool success :1;
} _BsnesDebugger_get_cpu_regs_presult__isset;

class BsnesDebugger_get_cpu_regs_presult {
 public:


  virtual ~BsnesDebugger_get_cpu_regs_presult() noexcept;
  BsnesRegisters* success;

  _BsnesDebugger_get_cpu_regs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _BsnesDebugger_set_cpu_reg_args__isset {
  _BsnesDebugger_set_cpu_reg_args__isset() : reg(false), value(false) {}
  bool reg :1;
  bool value :1;
} _BsnesDebugger_set_cpu_reg_args__isset;

class BsnesDebugger_set_cpu_reg_args {
 public:

  BsnesDebugger_set_cpu_reg_args(const BsnesDebugger_set_cpu_reg_args&);
  BsnesDebugger_set_cpu_reg_args& operator=(const BsnesDebugger_set_cpu_reg_args&);
  BsnesDebugger_set_cpu_reg_args() : reg((BsnesRegister::type)0), value(0) {
  }

  virtual ~BsnesDebugger_set_cpu_reg_args() noexcept;
  /**
   * 
   * @see BsnesRegister
   */
  BsnesRegister::type reg;
  int32_t value;

  _BsnesDebugger_set_cpu_reg_args__isset __isset;

  void __set_reg(const BsnesRegister::type val);

  void __set_value(const int32_t val);

  bool operator == (const BsnesDebugger_set_cpu_reg_args & rhs) const
  {
    if (!(reg == rhs.reg))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const BsnesDebugger_set_cpu_reg_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_set_cpu_reg_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_set_cpu_reg_pargs {
 public:


  virtual ~BsnesDebugger_set_cpu_reg_pargs() noexcept;
  /**
   * 
   * @see BsnesRegister
   */
  const BsnesRegister::type* reg;
  const int32_t* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_set_cpu_reg_result {
 public:

  BsnesDebugger_set_cpu_reg_result(const BsnesDebugger_set_cpu_reg_result&);
  BsnesDebugger_set_cpu_reg_result& operator=(const BsnesDebugger_set_cpu_reg_result&);
  BsnesDebugger_set_cpu_reg_result() {
  }

  virtual ~BsnesDebugger_set_cpu_reg_result() noexcept;

  bool operator == (const BsnesDebugger_set_cpu_reg_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_set_cpu_reg_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_set_cpu_reg_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_set_cpu_reg_presult {
 public:


  virtual ~BsnesDebugger_set_cpu_reg_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _BsnesDebugger_read_memory_args__isset {
  _BsnesDebugger_read_memory_args__isset() : src(false), address(false), size(false) {}
  bool src :1;
  bool address :1;
  bool size :1;
} _BsnesDebugger_read_memory_args__isset;

class BsnesDebugger_read_memory_args {
 public:

  BsnesDebugger_read_memory_args(const BsnesDebugger_read_memory_args&);
  BsnesDebugger_read_memory_args& operator=(const BsnesDebugger_read_memory_args&);
  BsnesDebugger_read_memory_args() : src((DbgMemorySource::type)0), address(0), size(0) {
  }

  virtual ~BsnesDebugger_read_memory_args() noexcept;
  /**
   * 
   * @see DbgMemorySource
   */
  DbgMemorySource::type src;
  int32_t address;
  int32_t size;

  _BsnesDebugger_read_memory_args__isset __isset;

  void __set_src(const DbgMemorySource::type val);

  void __set_address(const int32_t val);

  void __set_size(const int32_t val);

  bool operator == (const BsnesDebugger_read_memory_args & rhs) const
  {
    if (!(src == rhs.src))
      return false;
    if (!(address == rhs.address))
      return false;
    if (!(size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const BsnesDebugger_read_memory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_read_memory_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_read_memory_pargs {
 public:


  virtual ~BsnesDebugger_read_memory_pargs() noexcept;
  /**
   * 
   * @see DbgMemorySource
   */
  const DbgMemorySource::type* src;
  const int32_t* address;
  const int32_t* size;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BsnesDebugger_read_memory_result__isset {
  _BsnesDebugger_read_memory_result__isset() : success(false) {}
  bool success :1;
} _BsnesDebugger_read_memory_result__isset;

class BsnesDebugger_read_memory_result {
 public:

  BsnesDebugger_read_memory_result(const BsnesDebugger_read_memory_result&);
  BsnesDebugger_read_memory_result& operator=(const BsnesDebugger_read_memory_result&);
  BsnesDebugger_read_memory_result() : success() {
  }

  virtual ~BsnesDebugger_read_memory_result() noexcept;
  std::string success;

  _BsnesDebugger_read_memory_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const BsnesDebugger_read_memory_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const BsnesDebugger_read_memory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_read_memory_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _BsnesDebugger_read_memory_presult__isset {
  _BsnesDebugger_read_memory_presult__isset() : success(false) {}
  bool success :1;
} _BsnesDebugger_read_memory_presult__isset;

class BsnesDebugger_read_memory_presult {
 public:


  virtual ~BsnesDebugger_read_memory_presult() noexcept;
  std::string* success;

  _BsnesDebugger_read_memory_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _BsnesDebugger_write_memory_args__isset {
  _BsnesDebugger_write_memory_args__isset() : src(false), address(false), data(false) {}
  bool src :1;
  bool address :1;
  bool data :1;
} _BsnesDebugger_write_memory_args__isset;

class BsnesDebugger_write_memory_args {
 public:

  BsnesDebugger_write_memory_args(const BsnesDebugger_write_memory_args&);
  BsnesDebugger_write_memory_args& operator=(const BsnesDebugger_write_memory_args&);
  BsnesDebugger_write_memory_args() : src((DbgMemorySource::type)0), address(0), data() {
  }

  virtual ~BsnesDebugger_write_memory_args() noexcept;
  /**
   * 
   * @see DbgMemorySource
   */
  DbgMemorySource::type src;
  int32_t address;
  std::string data;

  _BsnesDebugger_write_memory_args__isset __isset;

  void __set_src(const DbgMemorySource::type val);

  void __set_address(const int32_t val);

  void __set_data(const std::string& val);

  bool operator == (const BsnesDebugger_write_memory_args & rhs) const
  {
    if (!(src == rhs.src))
      return false;
    if (!(address == rhs.address))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const BsnesDebugger_write_memory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_write_memory_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_write_memory_pargs {
 public:


  virtual ~BsnesDebugger_write_memory_pargs() noexcept;
  /**
   * 
   * @see DbgMemorySource
   */
  const DbgMemorySource::type* src;
  const int32_t* address;
  const std::string* data;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_write_memory_result {
 public:

  BsnesDebugger_write_memory_result(const BsnesDebugger_write_memory_result&);
  BsnesDebugger_write_memory_result& operator=(const BsnesDebugger_write_memory_result&);
  BsnesDebugger_write_memory_result() {
  }

  virtual ~BsnesDebugger_write_memory_result() noexcept;

  bool operator == (const BsnesDebugger_write_memory_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_write_memory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_write_memory_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_write_memory_presult {
 public:


  virtual ~BsnesDebugger_write_memory_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _BsnesDebugger_add_breakpoint_args__isset {
  _BsnesDebugger_add_breakpoint_args__isset() : bpt(false) {}
  bool bpt :1;
} _BsnesDebugger_add_breakpoint_args__isset;

class BsnesDebugger_add_breakpoint_args {
 public:

  BsnesDebugger_add_breakpoint_args(const BsnesDebugger_add_breakpoint_args&);
  BsnesDebugger_add_breakpoint_args& operator=(const BsnesDebugger_add_breakpoint_args&);
  BsnesDebugger_add_breakpoint_args() {
  }

  virtual ~BsnesDebugger_add_breakpoint_args() noexcept;
  DbgBreakpoint bpt;

  _BsnesDebugger_add_breakpoint_args__isset __isset;

  void __set_bpt(const DbgBreakpoint& val);

  bool operator == (const BsnesDebugger_add_breakpoint_args & rhs) const
  {
    if (!(bpt == rhs.bpt))
      return false;
    return true;
  }
  bool operator != (const BsnesDebugger_add_breakpoint_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_add_breakpoint_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_add_breakpoint_pargs {
 public:


  virtual ~BsnesDebugger_add_breakpoint_pargs() noexcept;
  const DbgBreakpoint* bpt;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_add_breakpoint_result {
 public:

  BsnesDebugger_add_breakpoint_result(const BsnesDebugger_add_breakpoint_result&);
  BsnesDebugger_add_breakpoint_result& operator=(const BsnesDebugger_add_breakpoint_result&);
  BsnesDebugger_add_breakpoint_result() {
  }

  virtual ~BsnesDebugger_add_breakpoint_result() noexcept;

  bool operator == (const BsnesDebugger_add_breakpoint_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_add_breakpoint_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_add_breakpoint_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_add_breakpoint_presult {
 public:


  virtual ~BsnesDebugger_add_breakpoint_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _BsnesDebugger_del_breakpoint_args__isset {
  _BsnesDebugger_del_breakpoint_args__isset() : bpt(false) {}
  bool bpt :1;
} _BsnesDebugger_del_breakpoint_args__isset;

class BsnesDebugger_del_breakpoint_args {
 public:

  BsnesDebugger_del_breakpoint_args(const BsnesDebugger_del_breakpoint_args&);
  BsnesDebugger_del_breakpoint_args& operator=(const BsnesDebugger_del_breakpoint_args&);
  BsnesDebugger_del_breakpoint_args() {
  }

  virtual ~BsnesDebugger_del_breakpoint_args() noexcept;
  DbgBreakpoint bpt;

  _BsnesDebugger_del_breakpoint_args__isset __isset;

  void __set_bpt(const DbgBreakpoint& val);

  bool operator == (const BsnesDebugger_del_breakpoint_args & rhs) const
  {
    if (!(bpt == rhs.bpt))
      return false;
    return true;
  }
  bool operator != (const BsnesDebugger_del_breakpoint_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_del_breakpoint_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_del_breakpoint_pargs {
 public:


  virtual ~BsnesDebugger_del_breakpoint_pargs() noexcept;
  const DbgBreakpoint* bpt;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_del_breakpoint_result {
 public:

  BsnesDebugger_del_breakpoint_result(const BsnesDebugger_del_breakpoint_result&);
  BsnesDebugger_del_breakpoint_result& operator=(const BsnesDebugger_del_breakpoint_result&);
  BsnesDebugger_del_breakpoint_result() {
  }

  virtual ~BsnesDebugger_del_breakpoint_result() noexcept;

  bool operator == (const BsnesDebugger_del_breakpoint_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_del_breakpoint_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_del_breakpoint_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_del_breakpoint_presult {
 public:


  virtual ~BsnesDebugger_del_breakpoint_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class BsnesDebugger_pause_args {
 public:

  BsnesDebugger_pause_args(const BsnesDebugger_pause_args&);
  BsnesDebugger_pause_args& operator=(const BsnesDebugger_pause_args&);
  BsnesDebugger_pause_args() {
  }

  virtual ~BsnesDebugger_pause_args() noexcept;

  bool operator == (const BsnesDebugger_pause_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_pause_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_pause_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_pause_pargs {
 public:


  virtual ~BsnesDebugger_pause_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_pause_result {
 public:

  BsnesDebugger_pause_result(const BsnesDebugger_pause_result&);
  BsnesDebugger_pause_result& operator=(const BsnesDebugger_pause_result&);
  BsnesDebugger_pause_result() {
  }

  virtual ~BsnesDebugger_pause_result() noexcept;

  bool operator == (const BsnesDebugger_pause_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_pause_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_pause_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_pause_presult {
 public:


  virtual ~BsnesDebugger_pause_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class BsnesDebugger_resume_args {
 public:

  BsnesDebugger_resume_args(const BsnesDebugger_resume_args&);
  BsnesDebugger_resume_args& operator=(const BsnesDebugger_resume_args&);
  BsnesDebugger_resume_args() {
  }

  virtual ~BsnesDebugger_resume_args() noexcept;

  bool operator == (const BsnesDebugger_resume_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_resume_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_resume_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_resume_pargs {
 public:


  virtual ~BsnesDebugger_resume_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_resume_result {
 public:

  BsnesDebugger_resume_result(const BsnesDebugger_resume_result&);
  BsnesDebugger_resume_result& operator=(const BsnesDebugger_resume_result&);
  BsnesDebugger_resume_result() {
  }

  virtual ~BsnesDebugger_resume_result() noexcept;

  bool operator == (const BsnesDebugger_resume_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_resume_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_resume_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_resume_presult {
 public:


  virtual ~BsnesDebugger_resume_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class BsnesDebugger_start_emulation_args {
 public:

  BsnesDebugger_start_emulation_args(const BsnesDebugger_start_emulation_args&);
  BsnesDebugger_start_emulation_args& operator=(const BsnesDebugger_start_emulation_args&);
  BsnesDebugger_start_emulation_args() {
  }

  virtual ~BsnesDebugger_start_emulation_args() noexcept;

  bool operator == (const BsnesDebugger_start_emulation_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_start_emulation_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_start_emulation_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_start_emulation_pargs {
 public:


  virtual ~BsnesDebugger_start_emulation_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_start_emulation_result {
 public:

  BsnesDebugger_start_emulation_result(const BsnesDebugger_start_emulation_result&);
  BsnesDebugger_start_emulation_result& operator=(const BsnesDebugger_start_emulation_result&);
  BsnesDebugger_start_emulation_result() {
  }

  virtual ~BsnesDebugger_start_emulation_result() noexcept;

  bool operator == (const BsnesDebugger_start_emulation_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_start_emulation_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_start_emulation_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_start_emulation_presult {
 public:


  virtual ~BsnesDebugger_start_emulation_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class BsnesDebugger_exit_emulation_args {
 public:

  BsnesDebugger_exit_emulation_args(const BsnesDebugger_exit_emulation_args&);
  BsnesDebugger_exit_emulation_args& operator=(const BsnesDebugger_exit_emulation_args&);
  BsnesDebugger_exit_emulation_args() {
  }

  virtual ~BsnesDebugger_exit_emulation_args() noexcept;

  bool operator == (const BsnesDebugger_exit_emulation_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_exit_emulation_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_exit_emulation_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_exit_emulation_pargs {
 public:


  virtual ~BsnesDebugger_exit_emulation_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_exit_emulation_result {
 public:

  BsnesDebugger_exit_emulation_result(const BsnesDebugger_exit_emulation_result&);
  BsnesDebugger_exit_emulation_result& operator=(const BsnesDebugger_exit_emulation_result&);
  BsnesDebugger_exit_emulation_result() {
  }

  virtual ~BsnesDebugger_exit_emulation_result() noexcept;

  bool operator == (const BsnesDebugger_exit_emulation_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_exit_emulation_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_exit_emulation_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_exit_emulation_presult {
 public:


  virtual ~BsnesDebugger_exit_emulation_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class BsnesDebugger_step_into_args {
 public:

  BsnesDebugger_step_into_args(const BsnesDebugger_step_into_args&);
  BsnesDebugger_step_into_args& operator=(const BsnesDebugger_step_into_args&);
  BsnesDebugger_step_into_args() {
  }

  virtual ~BsnesDebugger_step_into_args() noexcept;

  bool operator == (const BsnesDebugger_step_into_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_step_into_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_step_into_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_step_into_pargs {
 public:


  virtual ~BsnesDebugger_step_into_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_step_into_result {
 public:

  BsnesDebugger_step_into_result(const BsnesDebugger_step_into_result&);
  BsnesDebugger_step_into_result& operator=(const BsnesDebugger_step_into_result&);
  BsnesDebugger_step_into_result() {
  }

  virtual ~BsnesDebugger_step_into_result() noexcept;

  bool operator == (const BsnesDebugger_step_into_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_step_into_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_step_into_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_step_into_presult {
 public:


  virtual ~BsnesDebugger_step_into_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class BsnesDebugger_step_over_args {
 public:

  BsnesDebugger_step_over_args(const BsnesDebugger_step_over_args&);
  BsnesDebugger_step_over_args& operator=(const BsnesDebugger_step_over_args&);
  BsnesDebugger_step_over_args() {
  }

  virtual ~BsnesDebugger_step_over_args() noexcept;

  bool operator == (const BsnesDebugger_step_over_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_step_over_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_step_over_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_step_over_pargs {
 public:


  virtual ~BsnesDebugger_step_over_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_step_over_result {
 public:

  BsnesDebugger_step_over_result(const BsnesDebugger_step_over_result&);
  BsnesDebugger_step_over_result& operator=(const BsnesDebugger_step_over_result&);
  BsnesDebugger_step_over_result() {
  }

  virtual ~BsnesDebugger_step_over_result() noexcept;

  bool operator == (const BsnesDebugger_step_over_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsnesDebugger_step_over_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsnesDebugger_step_over_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class BsnesDebugger_step_over_presult {
 public:


  virtual ~BsnesDebugger_step_over_presult() noexcept;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class BsnesDebuggerClient : virtual public BsnesDebuggerIf {
 public:
  BsnesDebuggerClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  BsnesDebuggerClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  int32_t get_cpu_reg(const BsnesRegister::type reg);
  void send_get_cpu_reg(const BsnesRegister::type reg);
  int32_t recv_get_cpu_reg();
  void get_cpu_regs(BsnesRegisters& _return);
  void send_get_cpu_regs();
  void recv_get_cpu_regs(BsnesRegisters& _return);
  void set_cpu_reg(const BsnesRegister::type reg, const int32_t value);
  void send_set_cpu_reg(const BsnesRegister::type reg, const int32_t value);
  void recv_set_cpu_reg();
  void read_memory(std::string& _return, const DbgMemorySource::type src, const int32_t address, const int32_t size);
  void send_read_memory(const DbgMemorySource::type src, const int32_t address, const int32_t size);
  void recv_read_memory(std::string& _return);
  void write_memory(const DbgMemorySource::type src, const int32_t address, const std::string& data);
  void send_write_memory(const DbgMemorySource::type src, const int32_t address, const std::string& data);
  void recv_write_memory();
  void add_breakpoint(const DbgBreakpoint& bpt);
  void send_add_breakpoint(const DbgBreakpoint& bpt);
  void recv_add_breakpoint();
  void del_breakpoint(const DbgBreakpoint& bpt);
  void send_del_breakpoint(const DbgBreakpoint& bpt);
  void recv_del_breakpoint();
  void pause();
  void send_pause();
  void recv_pause();
  void resume();
  void send_resume();
  void recv_resume();
  void start_emulation();
  void send_start_emulation();
  void recv_start_emulation();
  void exit_emulation();
  void send_exit_emulation();
  void recv_exit_emulation();
  void step_into();
  void send_step_into();
  void recv_step_into();
  void step_over();
  void send_step_over();
  void recv_step_over();
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class BsnesDebuggerProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<BsnesDebuggerIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (BsnesDebuggerProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_get_cpu_reg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_cpu_regs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_cpu_reg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_read_memory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_write_memory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_add_breakpoint(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_del_breakpoint(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_pause(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_resume(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_start_emulation(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_exit_emulation(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_step_into(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_step_over(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  BsnesDebuggerProcessor(::std::shared_ptr<BsnesDebuggerIf> iface) :
    iface_(iface) {
    processMap_["get_cpu_reg"] = &BsnesDebuggerProcessor::process_get_cpu_reg;
    processMap_["get_cpu_regs"] = &BsnesDebuggerProcessor::process_get_cpu_regs;
    processMap_["set_cpu_reg"] = &BsnesDebuggerProcessor::process_set_cpu_reg;
    processMap_["read_memory"] = &BsnesDebuggerProcessor::process_read_memory;
    processMap_["write_memory"] = &BsnesDebuggerProcessor::process_write_memory;
    processMap_["add_breakpoint"] = &BsnesDebuggerProcessor::process_add_breakpoint;
    processMap_["del_breakpoint"] = &BsnesDebuggerProcessor::process_del_breakpoint;
    processMap_["pause"] = &BsnesDebuggerProcessor::process_pause;
    processMap_["resume"] = &BsnesDebuggerProcessor::process_resume;
    processMap_["start_emulation"] = &BsnesDebuggerProcessor::process_start_emulation;
    processMap_["exit_emulation"] = &BsnesDebuggerProcessor::process_exit_emulation;
    processMap_["step_into"] = &BsnesDebuggerProcessor::process_step_into;
    processMap_["step_over"] = &BsnesDebuggerProcessor::process_step_over;
  }

  virtual ~BsnesDebuggerProcessor() {}
};

class BsnesDebuggerProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  BsnesDebuggerProcessorFactory(const ::std::shared_ptr< BsnesDebuggerIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::std::shared_ptr< BsnesDebuggerIfFactory > handlerFactory_;
};

class BsnesDebuggerMultiface : virtual public BsnesDebuggerIf {
 public:
  BsnesDebuggerMultiface(std::vector<std::shared_ptr<BsnesDebuggerIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~BsnesDebuggerMultiface() {}
 protected:
  std::vector<std::shared_ptr<BsnesDebuggerIf> > ifaces_;
  BsnesDebuggerMultiface() {}
  void add(::std::shared_ptr<BsnesDebuggerIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  int32_t get_cpu_reg(const BsnesRegister::type reg) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_cpu_reg(reg);
    }
    return ifaces_[i]->get_cpu_reg(reg);
  }

  void get_cpu_regs(BsnesRegisters& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get_cpu_regs(_return);
    }
    ifaces_[i]->get_cpu_regs(_return);
    return;
  }

  void set_cpu_reg(const BsnesRegister::type reg, const int32_t value) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->set_cpu_reg(reg, value);
    }
    ifaces_[i]->set_cpu_reg(reg, value);
  }

  void read_memory(std::string& _return, const DbgMemorySource::type src, const int32_t address, const int32_t size) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->read_memory(_return, src, address, size);
    }
    ifaces_[i]->read_memory(_return, src, address, size);
    return;
  }

  void write_memory(const DbgMemorySource::type src, const int32_t address, const std::string& data) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->write_memory(src, address, data);
    }
    ifaces_[i]->write_memory(src, address, data);
  }

  void add_breakpoint(const DbgBreakpoint& bpt) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->add_breakpoint(bpt);
    }
    ifaces_[i]->add_breakpoint(bpt);
  }

  void del_breakpoint(const DbgBreakpoint& bpt) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->del_breakpoint(bpt);
    }
    ifaces_[i]->del_breakpoint(bpt);
  }

  void pause() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->pause();
    }
    ifaces_[i]->pause();
  }

  void resume() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->resume();
    }
    ifaces_[i]->resume();
  }

  void start_emulation() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->start_emulation();
    }
    ifaces_[i]->start_emulation();
  }

  void exit_emulation() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->exit_emulation();
    }
    ifaces_[i]->exit_emulation();
  }

  void step_into() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->step_into();
    }
    ifaces_[i]->step_into();
  }

  void step_over() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->step_over();
    }
    ifaces_[i]->step_over();
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class BsnesDebuggerConcurrentClient : virtual public BsnesDebuggerIf {
 public:
  BsnesDebuggerConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(prot);
  }
  BsnesDebuggerConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  int32_t get_cpu_reg(const BsnesRegister::type reg);
  int32_t send_get_cpu_reg(const BsnesRegister::type reg);
  int32_t recv_get_cpu_reg(const int32_t seqid);
  void get_cpu_regs(BsnesRegisters& _return);
  int32_t send_get_cpu_regs();
  void recv_get_cpu_regs(BsnesRegisters& _return, const int32_t seqid);
  void set_cpu_reg(const BsnesRegister::type reg, const int32_t value);
  int32_t send_set_cpu_reg(const BsnesRegister::type reg, const int32_t value);
  void recv_set_cpu_reg(const int32_t seqid);
  void read_memory(std::string& _return, const DbgMemorySource::type src, const int32_t address, const int32_t size);
  int32_t send_read_memory(const DbgMemorySource::type src, const int32_t address, const int32_t size);
  void recv_read_memory(std::string& _return, const int32_t seqid);
  void write_memory(const DbgMemorySource::type src, const int32_t address, const std::string& data);
  int32_t send_write_memory(const DbgMemorySource::type src, const int32_t address, const std::string& data);
  void recv_write_memory(const int32_t seqid);
  void add_breakpoint(const DbgBreakpoint& bpt);
  int32_t send_add_breakpoint(const DbgBreakpoint& bpt);
  void recv_add_breakpoint(const int32_t seqid);
  void del_breakpoint(const DbgBreakpoint& bpt);
  int32_t send_del_breakpoint(const DbgBreakpoint& bpt);
  void recv_del_breakpoint(const int32_t seqid);
  void pause();
  int32_t send_pause();
  void recv_pause(const int32_t seqid);
  void resume();
  int32_t send_resume();
  void recv_resume(const int32_t seqid);
  void start_emulation();
  int32_t send_start_emulation();
  void recv_start_emulation(const int32_t seqid);
  void exit_emulation();
  int32_t send_exit_emulation();
  void recv_exit_emulation(const int32_t seqid);
  void step_into();
  int32_t send_step_into();
  void recv_step_into(const int32_t seqid);
  void step_over();
  int32_t send_step_over();
  void recv_step_over(const int32_t seqid);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif



#endif
