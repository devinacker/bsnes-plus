/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "debug_proto_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kBsnesRegisterValues[] = {
  BsnesRegister::pc,
  BsnesRegister::a,
  BsnesRegister::x,
  BsnesRegister::y,
  BsnesRegister::s,
  BsnesRegister::d,
  BsnesRegister::db,
  BsnesRegister::p,
  BsnesRegister::mflag,
  BsnesRegister::xflag,
  BsnesRegister::eflag
};
const char* _kBsnesRegisterNames[] = {
  "pc",
  "a",
  "x",
  "y",
  "s",
  "d",
  "db",
  "p",
  "mflag",
  "xflag",
  "eflag"
};
const std::map<int, const char*> _BsnesRegister_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(11, _kBsnesRegisterValues, _kBsnesRegisterNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const BsnesRegister::type& val) {
  std::map<int, const char*>::const_iterator it = _BsnesRegister_VALUES_TO_NAMES.find(val);
  if (it != _BsnesRegister_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const BsnesRegister::type& val) {
  std::map<int, const char*>::const_iterator it = _BsnesRegister_VALUES_TO_NAMES.find(val);
  if (it != _BsnesRegister_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kBpTypeValues[] = {
  BpType::BP_PC,
  BpType::BP_READ,
  BpType::BP_WRITE
};
const char* _kBpTypeNames[] = {
  "BP_PC",
  "BP_READ",
  "BP_WRITE"
};
const std::map<int, const char*> _BpType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kBpTypeValues, _kBpTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const BpType::type& val) {
  std::map<int, const char*>::const_iterator it = _BpType_VALUES_TO_NAMES.find(val);
  if (it != _BpType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const BpType::type& val) {
  std::map<int, const char*>::const_iterator it = _BpType_VALUES_TO_NAMES.find(val);
  if (it != _BpType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kDbgMemorySourceValues[] = {
  DbgMemorySource::CPUBus,
  DbgMemorySource::APUBus,
  DbgMemorySource::APURAM,
  DbgMemorySource::DSP,
  DbgMemorySource::VRAM,
  DbgMemorySource::OAM,
  DbgMemorySource::CGRAM,
  DbgMemorySource::CartROM,
  DbgMemorySource::CartRAM,
  DbgMemorySource::SA1Bus,
  DbgMemorySource::SFXBus,
  DbgMemorySource::SGBBus,
  DbgMemorySource::SGBROM,
  DbgMemorySource::SGBRAM
};
const char* _kDbgMemorySourceNames[] = {
  "CPUBus",
  "APUBus",
  "APURAM",
  "DSP",
  "VRAM",
  "OAM",
  "CGRAM",
  "CartROM",
  "CartRAM",
  "SA1Bus",
  "SFXBus",
  "SGBBus",
  "SGBROM",
  "SGBRAM"
};
const std::map<int, const char*> _DbgMemorySource_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(14, _kDbgMemorySourceValues, _kDbgMemorySourceNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const DbgMemorySource::type& val) {
  std::map<int, const char*>::const_iterator it = _DbgMemorySource_VALUES_TO_NAMES.find(val);
  if (it != _DbgMemorySource_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const DbgMemorySource::type& val) {
  std::map<int, const char*>::const_iterator it = _DbgMemorySource_VALUES_TO_NAMES.find(val);
  if (it != _DbgMemorySource_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kDbgBptSourceValues[] = {
  DbgBptSource::CPUBus,
  DbgBptSource::APURAM,
  DbgBptSource::DSP,
  DbgBptSource::VRAM,
  DbgBptSource::OAM,
  DbgBptSource::CGRAM,
  DbgBptSource::SA1Bus,
  DbgBptSource::SFXBus,
  DbgBptSource::SGBBus
};
const char* _kDbgBptSourceNames[] = {
  "CPUBus",
  "APURAM",
  "DSP",
  "VRAM",
  "OAM",
  "CGRAM",
  "SA1Bus",
  "SFXBus",
  "SGBBus"
};
const std::map<int, const char*> _DbgBptSource_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kDbgBptSourceValues, _kDbgBptSourceNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const DbgBptSource::type& val) {
  std::map<int, const char*>::const_iterator it = _DbgBptSource_VALUES_TO_NAMES.find(val);
  if (it != _DbgBptSource_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const DbgBptSource::type& val) {
  std::map<int, const char*>::const_iterator it = _DbgBptSource_VALUES_TO_NAMES.find(val);
  if (it != _DbgBptSource_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


BsnesRegisters::~BsnesRegisters() noexcept {
}


void BsnesRegisters::__set_pc(const int32_t val) {
  this->pc = val;
}

void BsnesRegisters::__set_a(const int32_t val) {
  this->a = val;
}

void BsnesRegisters::__set_x(const int32_t val) {
  this->x = val;
}

void BsnesRegisters::__set_y(const int32_t val) {
  this->y = val;
}

void BsnesRegisters::__set_s(const int32_t val) {
  this->s = val;
}

void BsnesRegisters::__set_d(const int32_t val) {
  this->d = val;
}

void BsnesRegisters::__set_db(const int16_t val) {
  this->db = val;
}

void BsnesRegisters::__set_p(const int16_t val) {
  this->p = val;
}

void BsnesRegisters::__set_mflag(const int8_t val) {
  this->mflag = val;
}

void BsnesRegisters::__set_xflag(const int8_t val) {
  this->xflag = val;
}

void BsnesRegisters::__set_eflag(const int8_t val) {
  this->eflag = val;
}
std::ostream& operator<<(std::ostream& out, const BsnesRegisters& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BsnesRegisters::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pc);
          this->__isset.pc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->s);
          this->__isset.s = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->d);
          this->__isset.d = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->db);
          this->__isset.db = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->p);
          this->__isset.p = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mflag);
          this->__isset.mflag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->xflag);
          this->__isset.xflag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->eflag);
          this->__isset.eflag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BsnesRegisters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BsnesRegisters");

  xfer += oprot->writeFieldBegin("pc", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->pc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("a", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("s", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->s);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("d", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->d);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db", ::apache::thrift::protocol::T_I16, 7);
  xfer += oprot->writeI16(this->db);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("p", ::apache::thrift::protocol::T_I16, 8);
  xfer += oprot->writeI16(this->p);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mflag", ::apache::thrift::protocol::T_BYTE, 9);
  xfer += oprot->writeByte(this->mflag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xflag", ::apache::thrift::protocol::T_BYTE, 10);
  xfer += oprot->writeByte(this->xflag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eflag", ::apache::thrift::protocol::T_BYTE, 11);
  xfer += oprot->writeByte(this->eflag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BsnesRegisters &a, BsnesRegisters &b) {
  using ::std::swap;
  swap(a.pc, b.pc);
  swap(a.a, b.a);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.s, b.s);
  swap(a.d, b.d);
  swap(a.db, b.db);
  swap(a.p, b.p);
  swap(a.mflag, b.mflag);
  swap(a.xflag, b.xflag);
  swap(a.eflag, b.eflag);
  swap(a.__isset, b.__isset);
}

BsnesRegisters::BsnesRegisters(const BsnesRegisters& other0) {
  pc = other0.pc;
  a = other0.a;
  x = other0.x;
  y = other0.y;
  s = other0.s;
  d = other0.d;
  db = other0.db;
  p = other0.p;
  mflag = other0.mflag;
  xflag = other0.xflag;
  eflag = other0.eflag;
  __isset = other0.__isset;
}
BsnesRegisters& BsnesRegisters::operator=(const BsnesRegisters& other1) {
  pc = other1.pc;
  a = other1.a;
  x = other1.x;
  y = other1.y;
  s = other1.s;
  d = other1.d;
  db = other1.db;
  p = other1.p;
  mflag = other1.mflag;
  xflag = other1.xflag;
  eflag = other1.eflag;
  __isset = other1.__isset;
  return *this;
}
void BsnesRegisters::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BsnesRegisters(";
  out << "pc=" << to_string(pc);
  out << ", " << "a=" << to_string(a);
  out << ", " << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "s=" << to_string(s);
  out << ", " << "d=" << to_string(d);
  out << ", " << "db=" << to_string(db);
  out << ", " << "p=" << to_string(p);
  out << ", " << "mflag=" << to_string(mflag);
  out << ", " << "xflag=" << to_string(xflag);
  out << ", " << "eflag=" << to_string(eflag);
  out << ")";
}


DbgBreakpoint::~DbgBreakpoint() noexcept {
}


void DbgBreakpoint::__set_type(const BpType::type val) {
  this->type = val;
}

void DbgBreakpoint::__set_bstart(const int32_t val) {
  this->bstart = val;
}

void DbgBreakpoint::__set_bend(const int32_t val) {
  this->bend = val;
}

void DbgBreakpoint::__set_enabled(const bool val) {
  this->enabled = val;
}

void DbgBreakpoint::__set_src(const DbgBptSource::type val) {
  this->src = val;
}
std::ostream& operator<<(std::ostream& out, const DbgBreakpoint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DbgBreakpoint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->type = (BpType::type)ecast2;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bstart);
          this->__isset.bstart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bend);
          this->__isset.bend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enabled);
          this->__isset.enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->src = (DbgBptSource::type)ecast3;
          this->__isset.src = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DbgBreakpoint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DbgBreakpoint");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bstart", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bstart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bend", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->bend);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enabled", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("src", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->src);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DbgBreakpoint &a, DbgBreakpoint &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.bstart, b.bstart);
  swap(a.bend, b.bend);
  swap(a.enabled, b.enabled);
  swap(a.src, b.src);
  swap(a.__isset, b.__isset);
}

DbgBreakpoint::DbgBreakpoint(const DbgBreakpoint& other4) {
  type = other4.type;
  bstart = other4.bstart;
  bend = other4.bend;
  enabled = other4.enabled;
  src = other4.src;
  __isset = other4.__isset;
}
DbgBreakpoint& DbgBreakpoint::operator=(const DbgBreakpoint& other5) {
  type = other5.type;
  bstart = other5.bstart;
  bend = other5.bend;
  enabled = other5.enabled;
  src = other5.src;
  __isset = other5.__isset;
  return *this;
}
void DbgBreakpoint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DbgBreakpoint(";
  out << "type=" << to_string(type);
  out << ", " << "bstart=" << to_string(bstart);
  out << ", " << "bend=" << to_string(bend);
  out << ", " << "enabled=" << to_string(enabled);
  out << ", " << "src=" << to_string(src);
  out << ")";
}


